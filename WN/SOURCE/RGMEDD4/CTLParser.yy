%{
#include <stdio.h>
#include <cstdio>
#include <stdlib.h>
#include <time.h>
#include <signal.h>
#include <string>
#include <sstream>
#include <fstream>
#include <numeric>
#include "CTLLexer.ll.h"
#include "CTL.h"
#include "rgmedd4.h"
#include "parallel.h"

#define PERFORMANCECTL 1
#define PERFORMANCE 1

using namespace std;
using namespace ctlmdd;

extern const char* MCC_TECHNIQUES;
// CTLMDD *ctl = CTLMDD::getInstance();
static BaseFormula *ris = NULL;
// Are we parsing a boolean expression of HOA edges?
bool parsing_HOA_edge = false;
RSRG *rsrg;
static istringstream *Ibuffer;
static FlexLexer* lexer;
// tempi di clock quando inizia la generazione dell'MDD della formula, 
// quando finisce e dopo aver controllato la presenza dello stato iniziale nella formula
static clock_t startMDD, endMDD, endMDD2; 
// From the command line
extern bool print_CTL_counterexamples;
extern bool sort_CTL_queries;
// sequential/parallel model checking
int g_par_mc_max_time_round0 = -1;
int g_par_mc_num_parallel_procs = -1;
int g_par_mc_max_MB_statespace = -1;

static bool is_mc_parallel() { return g_par_mc_num_parallel_procs >= 0; }

const std::vector<size_t> *p_spot_ap_to_greatspn_ap_index = nullptr;
const std::vector<Formula*> *p_greatspn_atomic_propositions = nullptr;

void yyerror(const char *str) {
  cout<<"Parse error at \"" << lexer->YYText() << "\": " << str << "." << endl;
}
 
int yylex(void){
    int i = lexer->mmlex(); 
    return i;
}
extern int yyparse(void);
extern int output_flag;

// reverse the sign of an inequality (i.e. a < b -> b > a)
inline Inequality::op_type reverse_ineq_op(Inequality::op_type inop) {
    switch (inop) {
        case Inequality::IOP_MIN:       return Inequality::IOP_MAJ;
        case Inequality::IOP_MAJ:       return Inequality::IOP_MIN;
        case Inequality::IOP_MINEQ:     return Inequality::IOP_MAJEQ;
        case Inequality::IOP_MAJEQ:     return Inequality::IOP_MINEQ;
        default:                        return inop; // [not] equal
    }
}

inline Formula* fix_unquantified_ctlstar_formulas(Formula* f) {
    if (f->isPathFormula()) { // typeid(*f) != typeid(QuantifiedFormula) && 
        /* Formula* negFormula = new LogicalFormula(f); */
        /* f = new QuantifiedFormula(f, QOP_ALWAYS); */
        f = ctlnew<QuantifiedFormula>(f, QOP_ALWAYS);
	}
    return f;
}

struct ctl_query_t {
    std::string line;    // query in textual form
    std::string name;    // name for named formulas
    const CTLResult *expected; // expected result (if available)
    int score;           // complexity score
};

//-----------------------------------------------------------------------------
%}
%union{
  float num;
  char *pVar;
  int place_id;
  int spot_id;
  int mpar_id;
  int transition_id;
  ctlmdd::PlaceTerm *term;
  ctlmdd::Formula *formula;
  ctlmdd::IntFormula *int_formula;
  ctlmdd::Inequality::op_type inop;
  std::vector<int>* place_id_list;
  std::vector<int>* transition_id_list;
}

%token <num> NUMBER
%token <pVar> VAR 
%token <mpar_id> MARK_PAR
%token <place_id> PLACE_ID
%token <transition_id> TRANSITION_ID
%token PROP_NAME SPOT_ACCEPT_ALL
%token PLUS MINUS TIMES DIV MINOR MAJOR MINOREQ MAJOREQ EQ NEQ 
%token OR XOR AND NOT IMPLY BIIMPLY POSSIBLY IMPOSSIBLY INVARIANT
%token HAS_DEADLOCK QUASI_LIVENESS STABLE_MARKING LIVENESS ONESAFE
%token LPARENT RPARENT TRUEv FALSEv LQPARENT RQPARENT 
%token DEADLOCK NDEADLOCK ENABLED BOUNDS COMMA
%token SIM DIF SHARP SEMICOLON
%right E A U ENABLED BOUNDS POSSIBLY IMPOSSIBLY INVARIANT // AX AF AG EX EF EG
%right X F G EX EF EG AX AF AG
%left IMPLY BIIMPLY
%left OR XOR PIPE
%left AND AMPERSAND
%right NOT
//%nonassoc SIM DIF
%nonassoc EQ MINOR MAJOR MINOREQ MAJOREQ NEQ
%left PLUS MINUS
%left TIMES DIV
%token LTLStart // switch to parse spot_expression

%type <int_formula> expression
%type <place_id_list> place_list
%type <transition_id_list> transition_list
%type <formula> atomic_prop
%type <inop> ineq_op
%type <formula> ctlstar_formula 
%type <formula> spot_expression

%start inizio

%%
inizio: expression opt_semicolon  { ris = $1; }
      // | ctl_formula opt_semicolon { parsed_comment = false; ris = $1; }
	  | LTLStart spot_expression  { ris = $2; } /* parse LTL atomic propositions generated by SPOT */
      | ctlstar_formula opt_semicolon { ris = fix_unquantified_ctlstar_formulas($1); }
      // | PROP_NAME VAR             { parsed_comment = true; ris = NULL; query_name = $2; free($2); }
      // | /*empty*/                 { parsed_comment = true; ris = NULL; }
      ;

opt_semicolon: /*nothing*/ | SEMICOLON ;


/** Boolean expression parser for SPOT's edge labels **/
spot_expression: spot_expression AMPERSAND spot_expression { $$ = ctlnew<LogicalFormula>($1, $3, LogicalFormula::CBF_AND);}
			   | spot_expression AND spot_expression       { $$ = ctlnew<LogicalFormula>($1, $3, LogicalFormula::CBF_AND);}
           	   | spot_expression PIPE spot_expression      { $$ = ctlnew<LogicalFormula>($1, $3, LogicalFormula::CBF_OR); }
               | spot_expression OR spot_expression        { $$ = ctlnew<LogicalFormula>($1, $3, LogicalFormula::CBF_OR); }
           	   | NOT spot_expression                       { $$ = ctlnew<LogicalFormula>($2); }
               | SPOT_ACCEPT_ALL                           { $$ = ctlnew<BoolLiteral>(true); }
               | NUMBER
               {
                    // Atomic proposition index must be present in the corresponding array
                    assert(p_greatspn_atomic_propositions != nullptr);
                    if ($1 > p_spot_ap_to_greatspn_ap_index->size() || $1 < 0) {
                        throw "ERROR: Atomic Proposition index is not valid.";
                    }
                    size_t ap_index = (*p_spot_ap_to_greatspn_ap_index)[$1];
                    $$ = (*p_greatspn_atomic_propositions)[ap_index];
                    $$->addOwner();
               }
               ;

/** CTLStar (CTL*) Expression **/
ctlstar_formula: atomic_prop                       { $$ = $1; }
             | LPARENT ctlstar_formula RPARENT     { $$ = $2; }
             | ctlstar_formula AND ctlstar_formula { $$ = ctlnew<LogicalFormula>($1,$3, LogicalFormula::CBF_AND); }
             | ctlstar_formula OR ctlstar_formula  { $$ = ctlnew<LogicalFormula>($1,$3, LogicalFormula::CBF_OR); }
             | NOT ctlstar_formula                 { $$ = ctlnew<LogicalFormula>($2); }
             | ctlstar_formula IMPLY ctlstar_formula { $$ = ctlnew<LogicalFormula>($1,$3, LogicalFormula::CBF_IMPLY); }
             | ctlstar_formula BIIMPLY ctlstar_formula { m_assert(false, "TODO: BIIMPLY"); }
             | POSSIBLY ctlstar_formula            { $$ = ctlnew<Reachability>($2, Reachability::RPT_POSSIBILITY); }
             | IMPOSSIBLY ctlstar_formula          { $$ = ctlnew<Reachability>($2, Reachability::RPT_IMPOSSIBILITY); }
             | INVARIANT ctlstar_formula           { $$ = ctlnew<Reachability>($2, Reachability::RPT_INVARIANTLY); }
             | A ctlstar_formula                   { $$ = ctlnew<QuantifiedFormula>($2, QOP_ALWAYS); }
             | E ctlstar_formula                   { $$ = ctlnew<QuantifiedFormula>($2, QOP_EXISTS); }
             | X ctlstar_formula                   { $$ = ctlnew<TemporalFormula>($2, POT_NEXT); }
             | G ctlstar_formula                   { $$ = ctlnew<TemporalFormula>($2, POT_GLOBALLY); }
             | F ctlstar_formula                   { $$ = ctlnew<TemporalFormula>($2, POT_FUTURE); }
             | ctlstar_formula U ctlstar_formula   { $$ = ctlnew<TemporalFormula>($1, $3); }
             | LQPARENT ctlstar_formula U ctlstar_formula RQPARENT { $$ = ctlnew<TemporalFormula>($2, $4); }
             /* syntactic sugar */
             | EX ctlstar_formula                  { $$ = ctlnew<QuantifiedFormula>(ctlnew<TemporalFormula>($2, POT_NEXT), QOP_EXISTS); }
             | EG ctlstar_formula                  { $$ = ctlnew<QuantifiedFormula>(ctlnew<TemporalFormula>($2, POT_GLOBALLY), QOP_EXISTS); }
             | EF ctlstar_formula                  { $$ = ctlnew<QuantifiedFormula>(ctlnew<TemporalFormula>($2, POT_FUTURE), QOP_EXISTS); }
             | AX ctlstar_formula                  { $$ = ctlnew<QuantifiedFormula>(ctlnew<TemporalFormula>($2, POT_NEXT), QOP_ALWAYS); }
             | AG ctlstar_formula                  { $$ = ctlnew<QuantifiedFormula>(ctlnew<TemporalFormula>($2, POT_GLOBALLY), QOP_ALWAYS); }
             | AF ctlstar_formula                  { $$ = ctlnew<QuantifiedFormula>(ctlnew<TemporalFormula>($2, POT_FUTURE), QOP_ALWAYS); }
             /* global properties */
             | HAS_DEADLOCK                        { $$ = ctlnew<GlobalProperty>(GPT_HAS_DEADLOCK); }
             | QUASI_LIVENESS                      { $$ = ctlnew<GlobalProperty>(GPT_QUASI_LIVENESS); }
             | STABLE_MARKING                      { $$ = ctlnew<GlobalProperty>(GPT_STABLE_MARKING); }
             | LIVENESS                            { $$ = ctlnew<GlobalProperty>(GPT_LIVENESS); }
             | ONESAFE                             { $$ = ctlnew<GlobalProperty>(GPT_ONESAFE); }
             ;

atomic_prop: NDEADLOCK                       { $$ = ctlnew<Deadlock>(false); }
           | DEADLOCK                        { $$ = ctlnew<Deadlock>(true); }
           | TRUEv                           { $$ = ctlnew<BoolLiteral>(true); }
           | FALSEv                          { $$ = ctlnew<BoolLiteral>(false); }
           | ENABLED LPARENT transition_list RPARENT  { $$ = ctlnew<Fireability>($3); delete $3; }
           | expression ineq_op expression   { $$ = make_inequality($1, $2, $3); }
           ;

ineq_op: EQ        { $$ = Inequality::IOP_EQ; }
       | MINOR     { $$ = Inequality::IOP_MIN; }
       | MINOREQ   { $$ = Inequality::IOP_MINEQ; }
       | MAJOR     { $$ = Inequality::IOP_MAJ; }
       | MAJOREQ   { $$ = Inequality::IOP_MAJEQ; }
       | NEQ       { $$ = Inequality::IOP_NEQ; }
       ;

place_list: opt_sharp PLACE_ID                  { $$ = new std::vector<int>(); $$->push_back($2); }
          | place_list COMMA opt_sharp PLACE_ID { $$ = $1; $$->push_back($4); }

transition_list: /* nothing */                       { $$ = new std::vector<int>(); }
               | TRANSITION_ID                       { $$ = new std::vector<int>(); $$->push_back($1); }
               | transition_list COMMA TRANSITION_ID { $$ = $1; $$->push_back($3); }

expression: LPARENT expression RPARENT        { $$ = $2;}
          | opt_sharp PLACE_ID                { $$ = ctlnew<PlaceTerm>(1, $2, PlaceTerm::EOP_TIMES); }
          | BOUNDS LPARENT place_list RPARENT { $$ = ctlnew<BoundOfPlaces>($3); delete $3; }
          | NUMBER                            { $$ = ctlnew<IntLiteral>($1); }
          | MARK_PAR                          { $$ = ctlnew<IntLiteral>(tabmp[$1].mark_val); }
          | MINUS expression  %prec NOT       { $$ = make_expression(ctlnew<IntLiteral>(0), IntFormula::EOP_MINUS, $2); }
          | expression TIMES expression       { $$ = make_expression($1, IntFormula::EOP_TIMES, $3); }
          | expression DIV expression         { $$ = make_expression($1, IntFormula::EOP_DIV, $3); }
          | expression PLUS expression        { $$ = make_expression($1, IntFormula::EOP_PLUS, $3); }
          | expression MINUS expression       { $$ = make_expression($1, IntFormula::EOP_MINUS, $3); }
          ;


opt_sharp : /*nothing*/ | SHARP;


%%

//-----------------------------------------------------------------------------

// Create an Inequality* object, with some optimizations for the special cases
AtomicProposition* make_inequality(IntFormula* e1, Inequality::op_type op, IntFormula* e2) {
    bool e1const = (typeid(*e1) == typeid(IntLiteral));
    bool e2const = (typeid(*e2) == typeid(IntLiteral));
    bool e1term = (typeid(*e1) == typeid(PlaceTerm));
    bool e2term = (typeid(*e2) == typeid(PlaceTerm));
    // constant <op> constant   ->   can be replaced with true/false
    if (e1const && e2const) {
        float val1 = ((IntLiteral*)e1)->getConstant();
        float val2 = ((IntLiteral*)e2)->getConstant();
        e1->removeOwner();
        e2->removeOwner();
        bool result;
        switch (op) {
            case Inequality::IOP_MIN:     result = val1 < val2;    break;
            case Inequality::IOP_MINEQ:   result = val1 <= val2;   break;
            case Inequality::IOP_MAJ:     result = val1 > val2;    break;
            case Inequality::IOP_MAJEQ:   result = val1 >= val2;   break;
            case Inequality::IOP_EQ:      result = val1 == val2;   break;
            case Inequality::IOP_NEQ:     result = val1 != val2;   break;
            case Inequality::IOP_SIM:     result = val1 == val2;   break;
            case Inequality::IOP_DIF:     result = val1 != val2;   break;
            default: throw;
        }
        return ctlnew<BoolLiteral>(result);
    }
    // constant <op> expression  ->  reverse the operator and build an inequality with constant
    else if (e1const) {
        float val1 = ((IntLiteral*)e1)->getConstant();
        e1->removeOwner();
        return ctlnew<Inequality>(reverse_ineq_op(op), e2, val1);
    }
    // expression <op> constant  ->  inequality with constant
    else if (e2const) {
        float val2 = ((IntLiteral*)e2)->getConstant();
        e2->removeOwner();
        return ctlnew<Inequality>(op, e1, val2);
    }
    // remaining case:  expression <op> expression
    // Use SIM and DIF if the two expressions are simple terms.    
    if (e1term && e2term) {
        if (op == Inequality::IOP_EQ)
            op = Inequality::IOP_SIM;
        else if (op == Inequality::IOP_NEQ)
            op = Inequality::IOP_DIF;
    }
    return ctlnew<Inequality>(op, e1, e2);

}

//-----------------------------------------------------------------------------

IntFormula* make_expression(IntFormula* e1, IntFormula::op_type op, IntFormula* e2) {
    bool e1const = (typeid(*e1) == typeid(IntLiteral));
    bool e2const = (typeid(*e2) == typeid(IntLiteral));
    bool e2term = (typeid(*e2) == typeid(PlaceTerm));
    // Terms are constants -> combine them directly
    if (e1const && e2const) {
        float result;
        float val1 = ((IntLiteral*)e1)->getConstant();
        float val2 = ((IntLiteral*)e2)->getConstant();
        switch (op) {
            case IntFormula::EOP_TIMES:   result = val1 * val2;     break;
            case IntFormula::EOP_DIV:     result = val1 / val2;     break;
            case IntFormula::EOP_PLUS:    result = val1 + val2;     break;
            case IntFormula::EOP_MINUS:   result = val1 - val2;     break;
            default: throw;
        }
        e1->removeOwner();
        e2->removeOwner();
        return ctlnew<IntLiteral>(result);
    }
    // <constant> <*/> <PlaceTerm>  ->  combine into a single PlaceTerm
    else if (e1const && e2term) {
        if (op == IntFormula::EOP_TIMES || op == IntFormula::EOP_DIV) {
            int variable = ((PlaceTerm*)e2)->getVariable();
            float coeff = ((PlaceTerm*)e2)->getCoeff();
            float val1 = ((IntLiteral*)e1)->getConstant();
            assert(coeff == 1);
            e1->removeOwner();
            e2->removeOwner();
            return ctlnew<PlaceTerm>(val1, variable, op);
        }
    }
    // Otherwise, create an IntFormula* object
    return ctlnew<IntExpression>(e1, e2, op);
}

//-----------------------------------------------------------------------------

char ctl_result_buffer[32];
const char* format_result(const CTLResult& result, bool uppercase) {
    if (result.is_int()) {
        sprintf(ctl_result_buffer, "%d", result.get_int());
        return ctl_result_buffer; 
    }
    else if (result.is_bool())
        return result.get_bool() ? (uppercase ? "TRUE" : "true") :
                                   (uppercase ? "FALSE" : "false");
    else 
        return "?";
}

//-----------------------------------------------------------------------------

// Parse and evaluate a CTL formula
BaseFormula *parse_formula(const std::string& formula, CTLResult *out_result) {
    assert(ris == nullptr);
    Ibuffer = new istringstream(formula);
    lexer = new yyFlexLexer(Ibuffer);
    yyparse();
    delete lexer;
    delete Ibuffer;
    BaseFormula *parsedFrm = ris;
    ris = NULL;
    if(parsedFrm != NULL) {
        // parsedFrm->addOwner();
        startMDD = clock();
        if (!running_for_MCC() && !CTL_quiet) {
			/*cout << "==================" << endl;*/
			/*cout << "isPathFormula: " << parsedFrm->isPathFormula() << endl;*/
			/*parsedFrm->print(cout, true);*/
			/*cout << "\n==================" << endl;*/
            cout << "Processing: " << *parsedFrm << "  ->  " 
                 << (parsedFrm->isIntFormula()?"int":"bool") << endl;
        }

        if (parsedFrm->isIntFormula()) { 
            IntLiteral* intFrm = dynamic_cast<IntLiteral*>(parsedFrm);
            out_result->set_int(intFrm->getConstant());
        }
        else { // boolean formula
            Formula* boolFrm = dynamic_cast<Formula*>(parsedFrm);

            // Prepare the CTL evaluation context
            /* if(!(CTL_as_CTLstar || rsrg->useMonolithicNSF())) rsrg->buildMonolithicNSF(); */
            Context ctx(rsrg->getRS(), /* rsrg->getNSF(),  */true, true);

            // Get the Sat-set of the formula
            dd_edge dd = boolFrm->getMDD();
            assert(dd.getForest() != nullptr);
            endMDD = clock();

            // Evaluate the CTL expression:  s0 |= formula
            dd_edge r(rsrg->getForestMDD());

            /*cout << "Markings that satisfy the formula: \n";
            enumerator i(*dd);
            int nvar = rsrg->getDomain()->getNumVariables();
            while(i != 0) { // for each marking in the sat set
                int j;
                for(j=1; j <= nvar; j++) { // for each place
                    int val = *(i.getAssignments() + j);
                    const std::string& s = rsrg->getPL(j - 1);
                    if(val!=0) 
                        cout << s << "(" << val << ")";
                }
                ++i;
                cout << endl;
            }
            cout << endl;*/

            apply(INTERSECTION, rsrg->getInitMark(), dd, r);
            out_result->set_bool(!isEmptySet(r));
        }
        endMDD2=clock();
    }
    return parsedFrm;
}

//-----------------------------------------------------------------------------

// Parse spot edge labels (boolean expressions over atomic propositions)
// An edge label generated by SPOT has a form like:  0 & !2 | !1
//  where the numbers are the atomic propositions indices
Formula* 
parse_spot_formula(const std::string& formula, 
                   const std::vector<Formula*>& atomic_propositions,
                   const std::vector<size_t>& spot_ap_to_greatspn_ap_index)
{
    assert(p_greatspn_atomic_propositions == nullptr);
    assert(ris == nullptr);

    p_greatspn_atomic_propositions = &atomic_propositions;
    p_spot_ap_to_greatspn_ap_index = &spot_ap_to_greatspn_ap_index;
    std::string expr = "### " + formula;

    Ibuffer = new istringstream(expr);
    lexer = new yyFlexLexer(Ibuffer);
    parsing_HOA_edge = true;
    yyparse();
    delete lexer;
    delete Ibuffer;
    parsing_HOA_edge = false;
    Formula *stateFormula = (Formula*)ris;
    // stateFormula->addOwner();
    ris = NULL;

    // cout << "parse_spot_formula: " << formula << " parsed as: " << *stateFormula << endl;

    p_greatspn_atomic_propositions = nullptr;
    p_spot_ap_to_greatspn_ap_index = nullptr;

    return stateFormula;
};


//-----------------------------------------------------------------------------

// count number of nested parenthesis in property string
unsigned int max_nested_par(const std::string prop)
{
    unsigned int cnt = 0;
    unsigned int max = 0;

    for(const char& c: prop) {
        switch(c) {
        case '(':
        case '[':
            if(++cnt > max) max = cnt;
            break;
        case ')':
        case ']':
            --cnt;
            break;
        default:
            break;
        }
    }
    return max;
}

unsigned int num_path_ops(const std::string prop)
{
    unsigned int cnt = 0;
    std::string ops = "GFUX";
    for(const char& c: prop) {
        if(std::find(ops.begin(), ops.end(), c) != ops.end()) cnt++;
    }
    return cnt;
}

//-----------------------------------------------------------------------------

void model_check_query(const ctl_query_t& query, int sem_id) 
{
    // Compute the result
    CTLResult result;
    BaseFormula *formula = parse_formula(query.line, &result);

    // Compute the cardinality
    cardinality_t satset_card = -1;
    if (formula && formula->isBoolFormula() && CTL_print_sat_sets) {
        dd_edge dd(dynamic_cast<Formula*>(formula)->getMDD());
        apply(INTERSECTION, rsrg->getRS(), dd, dd);
        apply(CARDINALITY, dd, cardinality_ref(satset_card));
    }

    // stop the killing timer after query evaluation
    if (is_mc_parallel()) {
        alarm(0);
        signal(SIGALRM, SIG_DFL);
    }

    // From this point on, there should be only (fast) result visualization

    // if (!running_for_MCC() && !CTL_quiet)
    //     cout<<"--- "<<query.line<<" ---"<<endl;
    // if (output_flag)
    //     fout << "\n ********** " << query.line << " *********" << endl;

    // Show the result of this CTL formula
    if (formula == NULL) {
        semaphore_sentinel sent(sem_id);
        // if (output_flag) {
        //     fout << "Parse error." << endl;
        // }
        if (!running_for_MCC()) {
            cout<<"Parse error."<<endl;
            if (!query.name.empty())
                cout << "Formula: " << query.name << "  " << (CTL_quiet ? "" : "\n");
            cout << "\tEvaluation: -" << endl;
        }
        else {
            if (!query.name.empty())
                cout << "FORMULA " << query.name << " CANNOT_COMPUTE " << endl;
        }
    }
    else {
        semaphore_sentinel sent(sem_id);
        const char* ctl_endl = (CTL_quiet ? "" : "\n");

        // We have a valid evaluated CTL formula
        bool is_int_formula = formula->isIntFormula();

        // Regression test
        const char *regression_res = "";
        bool failed_regression = false;
        if (query.expected != nullptr) { // Regression test
            if (query.expected->is_undef())
                regression_res = "   [[??]]";
            else if (*query.expected == result)
                regression_res = "  [[OK]]";
            else {
                regression_res = "  [[FAILED]]";
                failed_regression = true;
            }
        }

        if (!running_for_MCC()) {
            if (!query.name.empty())
                cout << "Formula name: " << query.name << ctl_endl;
            cout << "  \tEvaluation: " << left << setw(8) 
                 << format_result(result, false) << regression_res << ctl_endl;
            // if (output_flag) {
            //     if (!query.name.empty())
            //         fout << "Formula name: " << query.name << endl;
            //     fout <<  "Evaluation: " << format_result(result, false) << endl;
            // }
            if (satset_card >= 0) {
                if (CTL_quiet)
                    cout << "  SAT=" << satset_card;
                else
                    cout << "\tSAT[ " << *formula <<" ] = " << satset_card << endl;
            }

            // // Print all the satisfying markings
            // if(output_flag && !is_int_formula) {
            //     Formula* state_formula = dynamic_cast<Formula*>(formula);
            //     dd_edge dd = state_formula->getMDD();
            //     rsrg->show_markings(fout, dd);
            // }
        
            if (!CTL_quiet) {
#if PERFORMANCECTL
                if (!is_int_formula)
                    cout<<"\tSat-set generation time: "<<setprecision(7)<<(double(endMDD-startMDD))/CLOCKS_PER_SEC<<" sec"<<endl;
                cout<<"\tEvaluation time: "<<setprecision(7)<<(double(endMDD2-startMDD))/CLOCKS_PER_SEC<<" sec"<<endl;
#endif
                // Counter-example/witness generation
                if (print_CTL_counterexamples && !is_int_formula) {
                    Formula* state_formula = dynamic_cast<Formula*>(formula);
                    cout << "\nGenerated " << (result.get_bool() ? "witness: " : "counter-example: ") << endl;
                    vector<int> state0(npl + 1);
                    enumerator it0(rsrg->getInitMark());
                    const int* tmp =it0.getAssignments();
                    std::copy(tmp, tmp+npl + 1, state0.begin());
                    
                    TraceType traceTy = (result.get_bool() ? TT_WITNESS : TT_COUNTEREXAMPLE);
                    TreeTraceNode *ttn = state_formula->generateTrace(state0, traceTy);
                    print_banner(" Trace ");
                    cout << "Initial state is: ";
                    CTLMDD::getInstance()->print_state(state0.data());
                    cout << endl;
                    ttn->print_trace();
                    cout << endl;
                    delete ttn;
                }
            }
            else {
#if PERFORMANCECTL
                if (!is_int_formula)
                    cout<<"  Sat-set gen.: "<<setprecision(7)<<(double(endMDD-startMDD))/CLOCKS_PER_SEC<<" sec. ";
                cout<<" Eval: "<<setprecision(7)<<(double(endMDD2-startMDD))/CLOCKS_PER_SEC<<" sec. ";
#endif
            }
            cout << endl;
        }
        else { 
            cout << "FORMULA " << query.name << " "
                 << format_result(result, true)
                 << " " << MCC_TECHNIQUES << "\n";
        }


        if (failed_regression) {
            if (!query.name.empty())
                cerr << "Expected CTL value of " << query.name;
            else
                cerr << "Expected CTL value";
            cerr << " is " << *query.expected << ", found "<<result<<endl;
            throw rgmedd_exception("Regression test failed.");
        }

        if (invoked_from_gui()) {
            cout << "#{GUI}# RESULT " << query.name << " " 
                 << format_result(result, true) << endl;
        }

        // Release the memory occupied by the CTL formula tree
        formula->removeOwner();
        formula = nullptr;
    }

    if (!running_for_MCC() && !CTL_quiet)
        cout << endl;
}

//-----------------------------------------------------------------------------

// Handle a timeout induced by an ALARM signal
void handle_sigalarm_quit_query_eval(int) {
    if (!running_for_MCC())
        printf("\n\n\nTimed out. Killing query evaluation...\n");
    exit(EXIT_TIMEOUT_MC_QUERY);
}

//-----------------------------------------------------------------------------

// Parse input ctl queries read from file. Print the formula result on screen.
void CTLParser(RSRG *r) {
    rsrg = r;
    std::string filename = rsrg->getPropName();
    ifstream in;
    if (filename == "")
        filename = rsrg->getNetName() + std::string("ctl");
    in.open(filename.c_str());
    if (!in)
    {
        cout<<"Error opening CTL file: "<<filename<<"\n";
        if (running_for_MCC())
            cout<<"CANNOT_COMPUTE"<<endl;
        exit(EXIT_FAILURE);
    }
    // inizializzo la classe CTL dove ho i riferimenti a rs foreste e domini per tutte le altre classi
    CTLMDD::getInstance()->CTLinit();
    // filename = filename + ".output";
    // ofstream fout;
    // if (output_flag)
    // {
    //     fout.open(filename.c_str());
    //     if (!fout)
    //     {
    //         cout<<"Error opening output CTL file: "<<filename<<"\n";
    //         if (running_for_MCC())
    //             cout<<"CANNOT_COMPUTE"<<endl;
    //         exit(EXIT_FAILURE);
    //     }
    // }

    // read all lines from the input file, and separate queries from comments.
    std::vector<ctl_query_t> queries;
    {
        std::string name, line;
        // unsigned int pcnt = 0;
        while(!in.eof()) {
            getline(in, line);
            if (!line.empty()) {
                if (line.rfind("%", 0) == std::string::npos) { // query line
                    queries.push_back(ctl_query_t{ .line = line, .name = name, 
                                                      .expected = nullptr, .score = 0});
                    name = "";
                    // pcnt++;
                } else { // comment line: property name is enclosed between quotes
                    line.erase(line.begin());
                    name.clear();
                    size_t last = line.find_last_of("\"");
                    size_t first = line.find_first_of("\"");
                    if (last != std::string::npos && first != last)
                        name = line.substr(first+1, last-first-1); // found quoted property name
                }
            }
        }
        in.close();
    }

    // sort CTL/CTL* queries according to a complexity function heuristics
    std::vector<size_t> query_order(queries.size());
    std::iota(query_order.begin(), query_order.end(), 0);
    if (sort_CTL_queries) {
        // sort(queries.begin(), queries.end(),
        //      [] (const auto& f, const auto& g) -> bool {
        //          // count max num. nested parenthesis
        //          const auto mpf = max_nested_par(get<0>(f));
        //          const auto mpg = max_nested_par(get<0>(g));

        //          // count num. path operators
        //          const auto nof = num_path_ops(get<0>(f));
        //          const auto nog = num_path_ops(get<0>(g));

        //          return mpf + nof < mpg + nog;
        //      });
        // if (!running_for_MCC() && !CTL_quiet)
        //     cout << "--- Sorted " << queries.size() << " queries ---" << endl;
    }

    // carica i risultati attesi delle query
    for (size_t i=0; i<queries.size(); i++) {
        queries[i].expected = rsrg->get_expected_ctl(i);
        if (!CTL_quiet && !running_for_MCC()) {
            // const auto n = get<1>(p);
            if (queries[i].expected)
                cout << queries[i].name 
                     << "\texpecting: " << *queries[i].expected
                     << ":\t" << queries[i].line << endl;
            else
                cout << queries[i].name << ":\t " << queries[i].line << endl;
        }
    }


    // Query evaluation
    int sem_id = -1;
    if (!is_mc_parallel()) {
        //=================================
        // Sequential query evaluation
        //=================================
        for(const ctl_query_t& q: queries) {
            model_check_query(q, sem_id);
        } 
        if (!running_for_MCC()) {
            cout << "CTL cache size: " << CTLMDD::getInstance()->cache_size() << endl;
        }
    }
    else {
        //=================================
        // Parallel query evaluation
        //=================================
        sem_id = semaphore_create();

        // PHASE 1: both time and memory bound
        std::vector<int> exitcodes;
        int qid = parallel_exec(g_par_mc_num_parallel_procs,
                                queries.size(), nullptr,
                                exitcodes, false && !running_for_MCC());
        if (qid >= 0) { // working subprocess            
            if (g_par_mc_max_time_round0 > 0) {
                // Start the timer
                signal(SIGALRM, handle_sigalarm_quit_query_eval);
                alarm(g_par_mc_max_time_round0);
            }
            if (g_par_mc_max_MB_statespace > 0)
                constraint_address_space(g_par_mc_max_MB_statespace);

            model_check_query(queries[qid], sem_id);
            exit(EXIT_SUCCESS);
        }
        // cout << "\n\nPHASE 2\n\n" << endl;

        // all parallel tasks have finished: collect the unfinished queries
        size_t n_timedout = 0;
        for (size_t i=0; i<queries.size(); i++) {
            if (WEXITSTATUS(exitcodes[i]) == EXIT_TIMEOUT_MC_QUERY)
                n_timedout++;
            else if (WEXITSTATUS(exitcodes[i]) != 0 && running_for_MCC() 
                     && !queries[i].name.empty()) {
                cout << "FORMULA " << queries[i].name 
                     << " CANNOT_COMPUTE " << endl;
            }
        }

        if (n_timedout > 0) {
            std::vector<int> exitcodes_ph2;
            // PHASE 2 - restart timed-out queries with unbounded time
            qid = parallel_exec(g_par_mc_num_parallel_procs,
                                queries.size(), nullptr,
                                exitcodes_ph2, false && !running_for_MCC());
            if (qid >= 0) { // working subprocess
                if (WEXITSTATUS(exitcodes[qid]) != EXIT_TIMEOUT_MC_QUERY)
                    exit(EXIT_SUCCESS); // already completed
                
                if (g_par_mc_max_MB_statespace > 0)
                    constraint_address_space(g_par_mc_max_MB_statespace);

                model_check_query(queries[qid], sem_id);
                exit(EXIT_SUCCESS);
            }

            // PHASE 3: notify unevaluated queries
            for (size_t i=0; i<queries.size(); i++) {
                if (WEXITSTATUS(exitcodes[i]) == EXIT_TIMEOUT_MC_QUERY && 
                    WEXITSTATUS(exitcodes_ph2[i]) != 0) 
                {
                    if (!queries[i].name.empty() && running_for_MCC())
                        cout << "FORMULA " << queries[i].name 
                             << " CANNOT_COMPUTE " << endl;
                }
            }
        }

        semaphore_close(sem_id);
    }

    // if (fout)
    //     fout.close();
    cout << "Ok." << endl;
}

//-----------------------------------------------------------------------------

